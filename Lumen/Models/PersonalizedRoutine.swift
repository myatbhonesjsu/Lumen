//
//  PersonalizedRoutine.swift
//  Lumen
//
//  Personalized skincare routine generated by AI
//

import Foundation
import SwiftData

// MARK: - API Response Models

struct RoutineGenerationResponse: Codable {
    let userId: String
    let routine: PersonalizedRoutineData
    let generatedAt: Int
    let analysisSummary: AnalysisSummary

    enum CodingKeys: String, CodingKey {
        case userId = "user_id"
        case routine
        case generatedAt = "generated_at"
        case analysisSummary = "analysis_summary"
    }
}

struct PersonalizedRoutineData: Codable {
    let morningRoutine: [RoutineStepData]
    let eveningRoutine: [RoutineStepData]
    let keyConcerns: [String]
    let overallStrategy: String
    let expectedTimeline: String
    let importantNotes: [String]

    enum CodingKeys: String, CodingKey {
        case morningRoutine = "morning_routine"
        case eveningRoutine = "evening_routine"
        case keyConcerns = "key_concerns"
        case overallStrategy = "overall_strategy"
        case expectedTimeline = "expected_timeline"
        case importantNotes = "important_notes"
    }
}

struct RoutineStepData: Codable, Identifiable {
    let id = UUID()
    let step: String
    let productType: String
    let reason: String
    let icon: String

    enum CodingKeys: String, CodingKey {
        case step
        case productType = "product_type"
        case reason
        case icon
    }
}

struct AnalysisSummary: Codable {
    let topConcerns: [String]
    let overallHealth: Double
    let skinAge: Int

    enum CodingKeys: String, CodingKey {
        case topConcerns = "top_concerns"
        case overallHealth = "overall_health"
        case skinAge = "skin_age"
    }
}

// MARK: - SwiftData Persisted Model

@Model
final class PersonalizedRoutine {
    var id: UUID
    var userId: String
    var generatedAt: Date

    // Routine data (stored as JSON strings for SwiftData compatibility)
    var morningRoutineJSON: String
    var eveningRoutineJSON: String
    var keyConcerns: [String]
    var overallStrategy: String
    var expectedTimeline: String
    var importantNotes: [String]

    // Analysis summary
    var topConcerns: [String]
    var overallHealth: Double
    var skinAge: Int

    init(
        id: UUID = UUID(),
        userId: String,
        generatedAt: Date,
        morningRoutineJSON: String,
        eveningRoutineJSON: String,
        keyConcerns: [String],
        overallStrategy: String,
        expectedTimeline: String,
        importantNotes: [String],
        topConcerns: [String],
        overallHealth: Double,
        skinAge: Int
    ) {
        self.id = id
        self.userId = userId
        self.generatedAt = generatedAt
        self.morningRoutineJSON = morningRoutineJSON
        self.eveningRoutineJSON = eveningRoutineJSON
        self.keyConcerns = keyConcerns
        self.overallStrategy = overallStrategy
        self.expectedTimeline = expectedTimeline
        self.importantNotes = importantNotes
        self.topConcerns = topConcerns
        self.overallHealth = overallHealth
        self.skinAge = skinAge
    }

    // Convenience initializer from API response
    convenience init(from response: RoutineGenerationResponse) {
        let encoder = JSONEncoder()
        let morningJSON = (try? String(data: encoder.encode(response.routine.morningRoutine), encoding: .utf8)) ?? "[]"
        let eveningJSON = (try? String(data: encoder.encode(response.routine.eveningRoutine), encoding: .utf8)) ?? "[]"

        self.init(
            userId: response.userId,
            generatedAt: Date(timeIntervalSince1970: TimeInterval(response.generatedAt)),
            morningRoutineJSON: morningJSON,
            eveningRoutineJSON: eveningJSON,
            keyConcerns: response.routine.keyConcerns,
            overallStrategy: response.routine.overallStrategy,
            expectedTimeline: response.routine.expectedTimeline,
            importantNotes: response.routine.importantNotes,
            topConcerns: response.analysisSummary.topConcerns,
            overallHealth: response.analysisSummary.overallHealth,
            skinAge: response.analysisSummary.skinAge
        )
    }

    // Get decoded morning routine steps
    var morningSteps: [RoutineStepData] {
        guard let data = morningRoutineJSON.data(using: .utf8) else { return [] }
        return (try? JSONDecoder().decode([RoutineStepData].self, from: data)) ?? []
    }

    // Get decoded evening routine steps
    var eveningSteps: [RoutineStepData] {
        guard let data = eveningRoutineJSON.data(using: .utf8) else { return [] }
        return (try? JSONDecoder().decode([RoutineStepData].self, from: data)) ?? []
    }
}

// MARK: - Request Model

struct RoutineGenerationRequest: Codable {
    let userId: String
    let latestAnalysis: LatestAnalysisData
    let budget: String
    let preferences: [String: String]?

    enum CodingKeys: String, CodingKey {
        case userId = "user_id"
        case latestAnalysis = "latest_analysis"
        case budget
        case preferences
    }
}

struct LatestAnalysisData: Codable {
    let acneLevel: Double
    let drynessLevel: Double
    let moistureLevel: Double
    let pigmentationLevel: Double
    let darkCircleLevel: Double
    let skinAge: Int
    let overallHealth: Double

    enum CodingKeys: String, CodingKey {
        case acneLevel
        case drynessLevel
        case moistureLevel
        case pigmentationLevel
        case darkCircleLevel
        case skinAge
        case overallHealth
    }

    // Convenience initializer from SkinMetric
    init(from metric: SkinMetric) {
        self.acneLevel = metric.acneLevel
        self.drynessLevel = metric.drynessLevel
        self.moistureLevel = metric.moistureLevel
        self.pigmentationLevel = metric.pigmentationLevel
        self.darkCircleLevel = metric.darkCircleLevel
        self.skinAge = metric.skinAge
        self.overallHealth = metric.overallHealth
    }
}
