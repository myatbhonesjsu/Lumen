//
//  PersonalizedInsightsService.swift
//  Lumen
//
//  Service for fetching personalized AI-generated insights from Bedrock multi-agent system
//  NO FALLBACKS - If API fails, it fails per user requirements
//

import Foundation
import CoreLocation

enum PersonalizedInsightsError: Error, LocalizedError {
    case invalidURL
    case networkError(Error)
    case decodingError(Error)
    case noInsightAvailable
    case apiFailed(String)

    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "Invalid API endpoint URL"
        case .networkError(let error):
            return "Network error: \(error.localizedDescription)"
        case .decodingError(let error):
            return "Failed to parse response: \(error.localizedDescription)"
        case .noInsightAvailable:
            return "No personalized insight available yet. Take a scan to generate insights."
        case .apiFailed(let message):
            return "API failed: \(message)"
        }
    }
}

class PersonalizedInsightsService {
    static let shared = PersonalizedInsightsService()

    private let apiEndpoint = AWSConfig.apiEndpoint
    private let requestTimeout: TimeInterval = 120.0 // 2 minutes for agent processing

    private init() {}

    // MARK: - Authentication Helper

    private func addAuthHeader(to request: inout URLRequest) {
        if let idToken = CognitoAuthService.shared.getIdToken() {
            request.setValue(idToken, forHTTPHeaderField: "Authorization")
        }
    }

    // MARK: - Get Latest Personalized Insight

    /// Fetch the most recent personalized insight generated by the multi-agent system
    /// This insight is automatically generated after each skin scan
    /// NO FALLBACK - If no insight exists or API fails, returns error
    func getLatestInsight(
        completion: @escaping (Result<PersonalizedInsight?, Error>) -> Void
    ) {
        guard let url = URL(string: "\(apiEndpoint)/daily-insights/latest") else {
            completion(.failure(PersonalizedInsightsError.invalidURL))
            return
        }

        var request = URLRequest(url: url, timeoutInterval: requestTimeout)
        request.httpMethod = "GET"

        addAuthHeader(to: &request)

        print("üîç Fetching latest personalized insight from multi-agent system...")

        URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                print("‚ùå Network error: \(error.localizedDescription)")
                completion(.failure(PersonalizedInsightsError.networkError(error)))
                return
            }

            guard let httpResponse = response as? HTTPURLResponse else {
                print("‚ùå Invalid response")
                completion(.failure(PersonalizedInsightsError.networkError(
                    NSError(domain: "PersonalizedInsightsService", code: -1,
                           userInfo: [NSLocalizedDescriptionKey: "Invalid response"])
                )))
                return
            }

            // 404 means no insight exists yet
            if httpResponse.statusCode == 404 {
                print("‚ö†Ô∏è  No insight available yet (404)")
                completion(.success(nil))
                return
            }

            guard (200...299).contains(httpResponse.statusCode) else {
                let statusCode = httpResponse.statusCode
                let errorBody = data != nil ? String(data: data!, encoding: .utf8) ?? "No error details" : "No response body"
                print("‚ùå API Error [\(statusCode)]: \(errorBody)")
                // NO FALLBACK - Return error as-is
                completion(.failure(PersonalizedInsightsError.apiFailed("HTTP \(statusCode): \(errorBody)")))
                return
            }

            guard let data = data, !data.isEmpty else {
                print("‚ùå Empty response body")
                completion(.success(nil))
                return
            }

            // Debug: Print raw response
            if let responseString = String(data: data, encoding: .utf8) {
                print("üì• Personalized Insight Response: \(responseString.prefix(500))")
            }

            do {
                // Configure decoder for date parsing
                let decoder = JSONDecoder()
                decoder.dateDecodingStrategy = .custom { decoder in
                    let container = try decoder.singleValueContainer()
                    let dateString = try container.decode(String.self)

                    // Try ISO8601 with fractional seconds first
                    let isoFormatter = ISO8601DateFormatter()
                    isoFormatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
                    if let date = isoFormatter.date(from: dateString) {
                        return date
                    }

                    // Try ISO8601 without fractional seconds
                    if let date = ISO8601DateFormatter().date(from: dateString) {
                        return date
                    }

                    // Try Python's isoformat with microseconds
                    let formatter = DateFormatter()
                    formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSSSS"
                    formatter.locale = Locale(identifier: "en_US_POSIX")
                    formatter.timeZone = TimeZone(secondsFromGMT: 0)

                    if let date = formatter.date(from: dateString) {
                        return date
                    }

                    // Fallback to current date if parsing fails
                    print("‚ö†Ô∏è  Failed to parse date: \(dateString), using current date")
                    return Date()
                }

                let apiResponse = try decoder.decode(PersonalizedInsightResponse.self, from: data)

                if apiResponse.success, let insight = apiResponse.data {
                    print("‚úÖ Successfully decoded personalized insight: \(insight.id)")
                    print("   Generated: \(insight.timeAgo)")
                    print("   Has environmental alert: \(insight.hasEnvironmentalAlert)")
                    completion(.success(insight))
                } else {
                    let errorMessage = apiResponse.error ?? "Unknown error from multi-agent system"
                    print("‚ùå Multi-agent system returned error: \(errorMessage)")
                    // NO FALLBACK - Return error
                    completion(.failure(PersonalizedInsightsError.apiFailed(errorMessage)))
                }
            } catch {
                print("‚ùå Decoding error: \(error.localizedDescription)")
                if let jsonString = String(data: data, encoding: .utf8) {
                    print("   Response body: \(jsonString.prefix(1000))")
                }
                // NO FALLBACK - Return decoding error
                completion(.failure(PersonalizedInsightsError.decodingError(error)))
            }
        }.resume()
    }

    // MARK: - Wait for Insight Generation

    /// Poll for insight generation after a scan
    /// Useful for showing loading state while multi-agent system processes
    func waitForInsight(
        maxAttempts: Int = 30,
        pollInterval: TimeInterval = 2.0,
        completion: @escaping (Result<PersonalizedInsight, Error>) -> Void
    ) {
        var attempt = 0

        func poll() {
            attempt += 1
            print("üîÑ Polling for insight (attempt \(attempt)/\(maxAttempts))...")

            getLatestInsight { result in
                switch result {
                case .success(let insight):
                    if let insight = insight {
                        // Got an insight!
                        completion(.success(insight))
                    } else if attempt < maxAttempts {
                        // No insight yet, try again
                        DispatchQueue.global().asyncAfter(deadline: .now() + pollInterval) {
                            poll()
                        }
                    } else {
                        // Max attempts reached
                        print("‚ùå Max polling attempts reached without finding insight")
                        completion(.failure(PersonalizedInsightsError.noInsightAvailable))
                    }

                case .failure(let error):
                    // API failed - NO FALLBACK, return error
                    completion(.failure(error))
                }
            }
        }

        poll()
    }
}
